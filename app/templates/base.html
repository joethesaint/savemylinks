<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="SaveMyLinks - Your personal link curator and bookmark manager">
    <meta name="theme-color" content="#667eea">
    <title>{% block title %}SaveMyLinks{% endblock %}</title>
    
    <!-- Preload critical resources -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <!-- Modern CSS Framework -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="{{ url_for('static', path='/style.css') }}">
    
    <!-- Three.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.144.0/build/three.min.js"></script>
    
    <!-- Modern Clippy CSS is included in the JS module -->
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ”—</text></svg>">
</head>
<body class="has-navbar-fixed-top">
    <!-- Navigation -->
    <nav class="navbar is-fixed-top has-shadow" role="navigation" aria-label="main navigation">
        <div class="container">
            <div class="navbar-brand">
                <a class="navbar-item brand-logo" href="/">
                    <span class="icon is-medium">
                        <i class="fas fa-link"></i>
                    </span>
                    <strong class="ml-2">SaveMyLinks</strong>
                </a>
                
                <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false" data-target="navbarBasic">
                    <span aria-hidden="true"></span>
                    <span aria-hidden="true"></span>
                    <span aria-hidden="true"></span>
                </a>
            </div>
            
            <div id="navbarBasic" class="navbar-menu">
                <div class="navbar-start">
                    <a class="navbar-item" href="/">
                        <span class="icon">
                            <i class="fas fa-home"></i>
                        </span>
                        <span>Home</span>
                    </a>
                    <a class="navbar-item" href="/add">
                        <span class="icon">
                            <i class="fas fa-plus"></i>
                        </span>
                        <span>Add Link</span>
                    </a>
                </div>
                
                <div class="navbar-end">
                    <div class="navbar-item">
                        <button id="theme-toggle" class="button is-ghost theme-toggle" title="Toggle theme">
                            <span class="icon">
                                <i id="theme-icon" class="fas fa-sun"></i>
                            </span>
                        </button>
                    </div>
                    <div class="navbar-item">
                        <div class="buttons">
                            <a class="button is-primary is-light" href="/add">
                                <strong>Add New Link</strong>
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <!-- Particle Canvas Background -->
    <canvas id="particle-canvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; pointer-events: none;"></canvas>

    <!-- Main Content -->
    <main class="main-content">
        <div class="container">
            {% block content %}{% endblock %}
        </div>
    </main>

    <!-- Footer -->
    <footer class="footer mt-6">
        <div class="container">
            <div class="content has-text-centered">
                <div class="columns is-vcentered">
                    <div class="column">
                        <p class="is-size-6">
                            <strong>SaveMyLinks</strong> - Your personal link curator
                        </p>
                        <p class="is-size-7 has-text-grey">
                            Organize, search, and manage your bookmarks with ease
                        </p>
                    </div>
                    <div class="column is-narrow">
                        <div class="field is-grouped">
                            <p class="control">
                                <a class="button is-small is-outlined" href="https://github.com" target="_blank">
                                    <span class="icon">
                                        <i class="fab fa-github"></i>
                                    </span>
                                    <span>GitHub</span>
                                </a>
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </footer>

    <!-- JavaScript for mobile menu -->
    <script>
        // Mobile menu functionality
        document.addEventListener('DOMContentLoaded', () => {
            const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);
            
            if ($navbarBurgers.length > 0) {
                $navbarBurgers.forEach(el => {
                    el.addEventListener('click', () => {
                        const target = el.dataset.target;
                        const $target = document.getElementById(target);
                        
                        el.classList.toggle('is-active');
                        $target.classList.toggle('is-active');
                    });
                });
            }
        });

        // Theme switching functionality
        document.addEventListener('DOMContentLoaded', () => {
            const themeToggle = document.getElementById('theme-toggle');
            const themeIcon = document.getElementById('theme-icon');
            const html = document.documentElement;
            
            // Check for saved theme preference or default to 'light'
            const currentTheme = localStorage.getItem('theme') || 'light';
            html.setAttribute('data-theme', currentTheme);
            updateThemeIcon(currentTheme);
            
            themeToggle.addEventListener('click', () => {
                const currentTheme = html.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                
                // Add animation class
                themeToggle.classList.add(newTheme === 'dark' ? 'dimming' : 'lighting');
                
                // Change theme after a short delay for animation
                setTimeout(() => {
                    html.setAttribute('data-theme', newTheme);
                    localStorage.setItem('theme', newTheme);
                    updateThemeIcon(newTheme);
                    
                    // Remove animation class after animation completes
                    setTimeout(() => {
                        themeToggle.classList.remove('dimming', 'lighting');
                    }, 600);
                }, 100);
            });
            
            function updateThemeIcon(theme) {
                if (theme === 'dark') {
                    themeIcon.className = 'fas fa-moon';
                } else {
                    themeIcon.className = 'fas fa-sun';
                }
            }
            
            // Canvas-based Green Dust Particle Effect
            const canvas = document.getElementById('particle-canvas');
            const ctx = canvas.getContext('2d');
            let particlesArray = [];
            
            // Set canvas size
            function setCanvasSize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            setCanvasSize();
            window.addEventListener('resize', setCanvasSize);
            
            // Mouse position
            let mouse = {
                x: null,
                y: null,
                radius: 100
            };
            
            window.addEventListener('mousemove', function(event) {
                mouse.x = event.x;
                mouse.y = event.y;
            });
            
            // Create particle class
            class Particle {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.size = Math.random() * 3 + 1;
                    this.speedX = Math.random() * 3 - 1.5;
                    this.speedY = Math.random() * 3 - 1.5;
                    this.color = `rgba(100, ${200 + Math.random() * 55}, 100, ${0.5 + Math.random() * 0.5})`;
                }
                
                update() {
                    // Move particles
                    this.x += this.speedX;
                    this.y += this.speedY;
                    
                    // Wrap around edges
                    if (this.x > canvas.width) this.x = 0;
                    if (this.x < 0) this.x = canvas.width;
                    if (this.y > canvas.height) this.y = 0;
                    if (this.y < 0) this.y = canvas.height;
                    
                    // Mouse interaction - particles react to mouse
                    const dx = mouse.x - this.x;
                    const dy = mouse.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < mouse.radius) {
                        const force = (mouse.radius - distance) / mouse.radius;
                        const forceDirectionX = dx / distance;
                        const forceDirectionY = dy / distance;
                        const directionX = forceDirectionX * force * 10;
                        const directionY = forceDirectionY * force * 10;
                        
                        this.speedX -= directionX;
                        this.speedY -= directionY;
                    }
                    
                    // Apply friction
                    this.speedX *= 0.99;
                    this.speedY *= 0.99;
                }
                
                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            // Initialize particles
            function initParticles() {
                particlesArray = [];
                const numberOfParticles = 150;
                
                for (let i = 0; i < numberOfParticles; i++) {
                    particlesArray.push(new Particle());
                }
                console.log(`Canvas particle system initialized with ${numberOfParticles} particles`);
            }
            
            // Animation loop
            function animateParticles() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                for (let i = 0; i < particlesArray.length; i++) {
                    particlesArray[i].update();
                    particlesArray[i].draw();
                }
                
                requestAnimationFrame(animateParticles);
            }
            
            // Reinitialize particles when window is resized
            window.addEventListener('resize', function() {
                setCanvasSize();
                initParticles();
            });
            
            // Remove mouse position when leaving canvas
            window.addEventListener('mouseout', function() {
                mouse.x = undefined;
                mouse.y = undefined;
            });
            
            function initCSSFallback() {
                console.log('Initializing Enhanced CSS fallback particle effect');
                
                // Create CSS particle container
                const particleContainer = document.createElement('div');
                particleContainer.style.position = 'fixed';
                particleContainer.style.top = '0';
                particleContainer.style.left = '0';
                particleContainer.style.width = '100%';
                particleContainer.style.height = '100%';
                particleContainer.style.pointerEvents = 'none';
                particleContainer.style.zIndex = '1';
                particleContainer.style.overflow = 'hidden';
                document.body.appendChild(particleContainer);
                
                // Create enhanced CSS particles with green theme
                const particleCount = 150;
                const cssParticles = [];
                
                // Green color palette
                const greenShades = [
                    'rgba(34, 197, 94, 0.8)',   // Primary green
                    'rgba(22, 163, 74, 0.7)',  // Dark green
                    'rgba(74, 222, 128, 0.6)', // Light green
                    'rgba(5, 150, 105, 0.8)',  // Secondary green
                    'rgba(132, 204, 22, 0.7)', // Accent green
                    'rgba(163, 230, 53, 0.6)'  // Bright green
                ];
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    const size = 8 + Math.random() * 12; // Varying sizes
                    
                    particle.style.position = 'absolute';
                    particle.style.width = size + 'px';
                    particle.style.height = size + 'px';
                    particle.style.borderRadius = '50%';
                    particle.style.backgroundColor = greenShades[Math.floor(Math.random() * greenShades.length)];
                    particle.style.opacity = '0.6';
                    particle.style.transition = 'all 0.3s ease-out';
                    particle.style.boxShadow = `0 0 ${size}px rgba(34, 197, 94, 0.4)`;
                    
                    // Add irregular shape with CSS clip-path for organic feel
                    const irregularity = 10 + Math.random() * 20;
                    particle.style.clipPath = `polygon(${irregularity}% 0%, 100% ${irregularity}%, ${100-irregularity}% 100%, 0% ${100-irregularity}%)`;
                    
                    // Random initial position
                    particle.style.left = Math.random() * window.innerWidth + 'px';
                    particle.style.top = Math.random() * window.innerHeight + 'px';
                    
                    particleContainer.appendChild(particle);
                    cssParticles.push({
                        element: particle,
                        x: Math.random() * window.innerWidth,
                        y: Math.random() * window.innerHeight,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        mass: 0.5 + Math.random() * 0.5,
                        restitution: 0.7 + Math.random() * 0.2,
                        noiseOffsetX: Math.random() * 1000,
                        noiseOffsetY: Math.random() * 1000,
                        organicSpeed: 0.01 + Math.random() * 0.02,
                        directionChangeTimer: Math.random() * 200,
                        baseOpacity: 0.6 + Math.random() * 0.3,
                        glowIntensity: Math.random(),
                        repulsionStrength: 0.8 + Math.random() * 0.4
                    });
                }
                
                // Enhanced mouse tracking and animation for CSS particles
                let cssMouseX = 0, cssMouseY = 0;
                
                function animateCSSParticles() {
                    const time = Date.now() * 0.001;
                    
                    cssParticles.forEach((particle, index) => {
                        // Apply gravity
                        particle.vy += 0.05;
                        
                        // Organic movement
                        particle.noiseOffsetX += particle.organicSpeed;
                        particle.noiseOffsetY += particle.organicSpeed;
                        
                        const noiseX = Math.sin(particle.noiseOffsetX) * 0.5;
                        const noiseY = Math.cos(particle.noiseOffsetY) * 0.5;
                        
                        particle.vx += noiseX;
                        particle.vy += noiseY;
                        
                        // Random direction changes
                        particle.directionChangeTimer--;
                        if (particle.directionChangeTimer <= 0) {
                            particle.vx += (Math.random() - 0.5) * 2;
                            particle.vy += (Math.random() - 0.5) * 2;
                            particle.directionChangeTimer = 100 + Math.random() * 200;
                        }
                        
                        // Mouse repulsion
                        const dx = cssMouseX - particle.x;
                        const dy = cssMouseY - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 150 && distance > 0) {
                            const repulsionForce = (150 - distance) / 150 * particle.repulsionStrength;
                            particle.vx -= dx * repulsionForce * 0.1;
                            particle.vy -= dy * repulsionForce * 0.1;
                        }
                        
                        // Apply velocity
                        particle.x += particle.vx;
                        particle.y += particle.vy;
                        
                        // Edge bouncing with energy loss
                        if (particle.x <= 0 || particle.x >= window.innerWidth) {
                            particle.vx *= -particle.restitution;
                            particle.x = particle.x <= 0 ? 0 : window.innerWidth;
                        }
                        
                        if (particle.y <= 0 || particle.y >= window.innerHeight) {
                            particle.vy *= -particle.restitution;
                            particle.y = particle.y <= 0 ? 0 : window.innerHeight;
                        }
                        
                        // Velocity damping
                        particle.vx *= 0.995;
                        particle.vy *= 0.995;
                        
                        // Update position
                        particle.element.style.left = particle.x + 'px';
                        particle.element.style.top = particle.y + 'px';
                        
                        // Glow effect
                        const glowPulse = Math.sin(time * 2 + particle.glowIntensity * 10) * 0.2 + 0.8;
                        particle.element.style.opacity = particle.baseOpacity * glowPulse;
                        
                        // Particle connections (simplified for CSS)
                        for (let j = index + 1; j < Math.min(index + 5, cssParticles.length); j++) {
                            const other = cssParticles[j];
                            const connectionDistance = Math.sqrt(
                                (other.x - particle.x) ** 2 + (other.y - particle.y) ** 2
                            );
                            
                            if (connectionDistance < 100) {
                                // Create temporary connection line (simplified)
                                const connectionOpacity = (100 - connectionDistance) / 100 * 0.3;
                                particle.element.style.boxShadow = `0 0 20px rgba(34, 197, 94, ${connectionOpacity})`;
                            }
                        }
                    });
                    
                    requestAnimationFrame(animateCSSParticles);
                }
                
                document.addEventListener('mousemove', function(e) {
                    cssMouseX = e.clientX;
                    cssMouseY = e.clientY;
                });
                
                // Start CSS animation
                animateCSSParticles();
                
                console.log('Enhanced CSS fallback particle effect initialized');
            }
            
            // Initialize Canvas particle system when page loads
            initParticles();
            animateParticles();
        });
    </script>
    
    <!-- Clippy Assistant Scripts -->
    <!-- Modern Clippy Assistant Scripts - Loaded after main content -->
    <script type="module">
        let clippy;
        let randomMovementInterval;
        
        function startRandomAnimations() {
            if (randomMovementInterval) clearInterval(randomMovementInterval);
            
            randomMovementInterval = setInterval(() => {
                if (!clippy) return;
                
                // Use correct animation names from modern-clippy
                const animations = ['Idle', 'Wave', 'Thinking', 'Explain', 'GetAttention', 'Congratulate'];
                const randomAnimation = animations[Math.floor(Math.random() * animations.length)];
                
                clippy.play(randomAnimation);
                
                // Occasionally speak random messages
                if (Math.random() < 0.4) {
                    const messages = [
                        "Need any help?",
                        "I'm here if you need assistance!",
                        "Exploring the website?",
                        "Let me know if you have questions!",
                        "Looking good!",
                        "How's it going?",
                        "Anything I can help with?"
                    ];
                    const randomMessage = messages[Math.floor(Math.random() * messages.length)];
                    setTimeout(() => {
                        clippy.speak(randomMessage);
                    }, 500);
                }
            }, 3000 + Math.random() * 4000); // Faster interval between 3-7 seconds
        }
        
        async function initModernClippy() {
            try {
                // Dynamic import to load Clippy after main content
                const { initClippy } = await import('/static/modern-clippy.js');
                
                clippy = await initClippy({ basePath: '/static/' });
                
                // Add drag functionality
                let isDragging = false;
                let dragOffset = { x: 0, y: 0 };
                
                const clippyContainer = clippy.container;
                
                // Mouse down event
                clippyContainer.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    const rect = clippyContainer.getBoundingClientRect();
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                    clippyContainer.style.cursor = 'grabbing';
                    
                    // Stop animations while dragging
                    if (randomMovementInterval) {
                        clearInterval(randomMovementInterval);
                        randomMovementInterval = null;
                    }
                    
                    e.preventDefault();
                });
                
                // Mouse move event
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const newX = window.innerWidth - (e.clientX - dragOffset.x + clippyContainer.offsetWidth);
                    const newY = window.innerHeight - (e.clientY - dragOffset.y + clippyContainer.offsetHeight);
                    
                    // Keep within bounds
                    const boundedX = Math.max(20, Math.min(newX, window.innerWidth - 150));
                    const boundedY = Math.max(20, Math.min(newY, window.innerHeight - 120));
                    
                    clippyContainer.style.right = boundedX + 'px';
                    clippyContainer.style.bottom = boundedY + 'px';
                });
                
                // Mouse up event
                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        clippyContainer.style.cursor = 'grab';
                        
                        // Restart animations after a brief delay
                        setTimeout(() => {
                            if (!randomMovementInterval) {
                                startRandomAnimations();
                            }
                        }, 2000);
                    }
                });
                
                // Set initial cursor
                clippyContainer.style.cursor = 'grab';
                
                // Welcome message
                setTimeout(() => {
                    clippy.play('GetAttention');
                    setTimeout(() => {
                        clippy.speak("Hello! I'm your assistant. I'm here to help you navigate this website!");
                        // Start random animations after welcome
                        setTimeout(startRandomAnimations, 2000);
                    }, 500);
                }, 1000);
                
            } catch (error) {
                console.error('Failed to initialize Modern Clippy:', error);
            }
        }
        
        // Initialize after main content is fully loaded
        window.addEventListener('load', () => {
            // Add delay to ensure main content is prioritized
            setTimeout(initModernClippy, 1000);
        });
    </script>
    
</body>
</html>