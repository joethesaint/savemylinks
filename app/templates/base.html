<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="SaveMyLinks - Your personal link curator and bookmark manager">
    <meta name="theme-color" content="#667eea">
    <title>{% block title %}SaveMyLinks{% endblock %}</title>
    
    <!-- Preload critical resources -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <!-- Modern CSS Framework -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="{{ url_for('static', path='/style.css') }}">
    
    <!-- Three.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.144.0/build/three.min.js"></script>
    
    <!-- Modern Clippy CSS is included in the JS module -->
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ”—</text></svg>">
</head>
<body class="has-navbar-fixed-top">
    <!-- Navigation -->
    <nav class="navbar is-fixed-top has-shadow" role="navigation" aria-label="main navigation">
        <div class="container">
            <div class="navbar-brand">
                <a class="navbar-item brand-logo" href="/">
                    <span class="icon is-medium">
                        <i class="fas fa-link"></i>
                    </span>
                    <strong class="ml-2">SaveMyLinks</strong>
                </a>
                
                <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false" data-target="navbarBasic">
                    <span aria-hidden="true"></span>
                    <span aria-hidden="true"></span>
                    <span aria-hidden="true"></span>
                </a>
            </div>
            
            <div id="navbarBasic" class="navbar-menu">
                <div class="navbar-start">
                    <a class="navbar-item" href="/">
                        <span class="icon">
                            <i class="fas fa-home"></i>
                        </span>
                        <span>Home</span>
                    </a>
                    <a class="navbar-item" href="/add">
                        <span class="icon">
                            <i class="fas fa-plus"></i>
                        </span>
                        <span>Add Link</span>
                    </a>
                </div>
                
                <div class="navbar-end">
                    <div class="navbar-item">
                        <button id="theme-toggle" class="button is-ghost theme-toggle" title="Toggle theme">
                            <span class="icon">
                                <i id="theme-icon" class="fas fa-sun"></i>
                            </span>
                        </button>
                    </div>
                    <div class="navbar-item">
                        <div class="buttons">
                            <a class="button is-primary is-light" href="/add">
                                <strong>Add New Link</strong>
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="main-content">
        <div class="container">
            {% block content %}{% endblock %}
        </div>
    </main>

    <!-- Footer -->
    <footer class="footer mt-6">
        <div class="container">
            <div class="content has-text-centered">
                <div class="columns is-vcentered">
                    <div class="column">
                        <p class="is-size-6">
                            <strong>SaveMyLinks</strong> - Your personal link curator
                        </p>
                        <p class="is-size-7 has-text-grey">
                            Organize, search, and manage your bookmarks with ease
                        </p>
                    </div>
                    <div class="column is-narrow">
                        <div class="field is-grouped">
                            <p class="control">
                                <a class="button is-small is-outlined" href="https://github.com" target="_blank">
                                    <span class="icon">
                                        <i class="fab fa-github"></i>
                                    </span>
                                    <span>GitHub</span>
                                </a>
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </footer>

    <!-- JavaScript for mobile menu -->
    <script>
        // Mobile menu functionality
        document.addEventListener('DOMContentLoaded', () => {
            const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);
            
            if ($navbarBurgers.length > 0) {
                $navbarBurgers.forEach(el => {
                    el.addEventListener('click', () => {
                        const target = el.dataset.target;
                        const $target = document.getElementById(target);
                        
                        el.classList.toggle('is-active');
                        $target.classList.toggle('is-active');
                    });
                });
            }
        });

        // Theme switching functionality
        document.addEventListener('DOMContentLoaded', () => {
            const themeToggle = document.getElementById('theme-toggle');
            const themeIcon = document.getElementById('theme-icon');
            const html = document.documentElement;
            
            // Check for saved theme preference or default to 'light'
            const currentTheme = localStorage.getItem('theme') || 'light';
            html.setAttribute('data-theme', currentTheme);
            updateThemeIcon(currentTheme);
            
            themeToggle.addEventListener('click', () => {
                const currentTheme = html.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                
                // Add animation class
                themeToggle.classList.add(newTheme === 'dark' ? 'dimming' : 'lighting');
                
                // Change theme after a short delay for animation
                setTimeout(() => {
                    html.setAttribute('data-theme', newTheme);
                    localStorage.setItem('theme', newTheme);
                    updateThemeIcon(newTheme);
                    
                    // Remove animation class after animation completes
                    setTimeout(() => {
                        themeToggle.classList.remove('dimming', 'lighting');
                    }, 600);
                }, 100);
            });
            
            function updateThemeIcon(theme) {
                if (theme === 'dark') {
                    themeIcon.className = 'fas fa-moon';
                } else {
                    themeIcon.className = 'fas fa-sun';
                }
            }
            
            // Three.js Mouse-Following Particle Effect
            let scene, camera, renderer, particles = [];
            let mouseX = 0, mouseY = 0;
            let targetMouseX = 0, targetMouseY = 0;
            
            function initThreeJS() {
                try {
                    console.log('Initializing Three.js particle system...');
                    
                    // Check if WebGL is supported
                    if (!window.WebGLRenderingContext) {
                        console.log('WebGL not supported, using CSS fallback');
                        initCSSFallback();
                        return;
                    }
                    
                    // Create scene
                    scene = new THREE.Scene();
                    
                    // Create camera
                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    camera.position.z = 10;
                    
                    // Create renderer with error handling
                    try {
                        renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                        renderer.setSize(window.innerWidth, window.innerHeight);
                        renderer.domElement.style.position = 'fixed';
                        renderer.domElement.style.top = '0';
                        renderer.domElement.style.left = '0';
                        renderer.domElement.style.pointerEvents = 'none';
                        renderer.domElement.style.zIndex = '1';
                        document.body.appendChild(renderer.domElement);
                        console.log('Three.js renderer created and added to DOM');
                    } catch (e) {
                        console.error('WebGL renderer failed, falling back to CSS:', e);
                        initCSSFallback();
                        return;
                    }
                    
                    // Create simple particle system with tiny dust-like particles
                    const particleCount = 120;
                    const geometry = new THREE.CircleGeometry(0.05, 6); // Much smaller particles like dust
                    
                    // Create particles with subtle, dust-like materials
                    const dustColors = [
                        new THREE.Color(0x888888), // Gray dust
                        new THREE.Color(0x999999), // Light gray
                        new THREE.Color(0x777777), // Dark gray
                        new THREE.Color(0xaaaaaa), // Very light gray
                        new THREE.Color(0x666666)  // Darker gray
                    ];
                    
                    for (let i = 0; i < particleCount; i++) {
                        const material = new THREE.MeshBasicMaterial({
                            color: dustColors[Math.floor(Math.random() * dustColors.length)],
                            transparent: true,
                            opacity: 0.3 + Math.random() * 0.2 // Lower opacity for dust effect
                        });
                        
                        const particle = new THREE.Mesh(geometry, material);
                        
                        // Random initial position
                        particle.position.x = (Math.random() - 0.5) * 20;
                        particle.position.y = (Math.random() - 0.5) * 15;
                        particle.position.z = (Math.random() - 0.5) * 5;
                        
                        // Store boid behavior data
                        particle.userData = {
                            originalX: particle.position.x,
                            originalY: particle.position.y,
                            velocityX: (Math.random() - 0.5) * 0.02,
                            velocityY: (Math.random() - 0.5) * 0.02,
                            age: Math.random() * 100,
                            baseOpacity: material.opacity,
                            // Boid behavior properties
                            separationRadius: 0.5,
                            alignmentRadius: 1.0,
                            cohesionRadius: 1.5,
                            maxSpeed: 0.03,
                            maxForce: 0.001
                        };
                        
                        particles.push(particle);
                        scene.add(particle);
                    }
                    
                    console.log(`Created ${particleCount} particles`);
                    
                    // Start animation loop
                    animate();
                    
                    console.log('Three.js particle system initialization complete');
                } catch (error) {
                    console.error('Error initializing Three.js:', error);
                    console.log('Falling back to CSS gradient');
                    initCSSFallback();
                }
            }
            
            function initCSSFallback() {
                console.log('Initializing CSS fallback particle effect');
                
                // Create CSS particle container
                const particleContainer = document.createElement('div');
                particleContainer.style.position = 'fixed';
                particleContainer.style.top = '0';
                particleContainer.style.left = '0';
                particleContainer.style.width = '100%';
                particleContainer.style.height = '100%';
                particleContainer.style.pointerEvents = 'none';
                particleContainer.style.zIndex = '1';
                particleContainer.style.overflow = 'hidden';
                document.body.appendChild(particleContainer);
                
                // Create CSS particles with larger, more visible dots
                const particleCount = 60;
                const cssParticles = [];
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.style.position = 'absolute';
                    particle.style.width = '12px';  // Much larger
                    particle.style.height = '12px'; // Much larger
                    particle.style.borderRadius = '50%';
                    particle.style.backgroundColor = `hsl(${120 + Math.random() * 40}, 90%, ${60 + Math.random() * 20}%)`;
                    particle.style.opacity = '0.9'; // Higher opacity
                    particle.style.transition = 'all 0.2s ease-out';
                    particle.style.boxShadow = '0 0 10px rgba(0, 255, 0, 0.5)'; // Glow effect
                    
                    // Random initial position
                    particle.style.left = Math.random() * window.innerWidth + 'px';
                    particle.style.top = Math.random() * window.innerHeight + 'px';
                    
                    particleContainer.appendChild(particle);
                    cssParticles.push({
                        element: particle,
                        x: Math.random() * window.innerWidth,
                        y: Math.random() * window.innerHeight,
                        vx: 0,
                        vy: 0
                    });
                }
                
                // Mouse tracking for CSS particles
                let cssMouseX = 0, cssMouseY = 0;
                
                document.addEventListener('mousemove', function(e) {
                    cssMouseX = e.clientX;
                    cssMouseY = e.clientY;
                    
                    cssParticles.forEach(particle => {
                        const dx = cssMouseX - particle.x;
                        const dy = cssMouseY - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 200) {
                            const force = (200 - distance) / 200;
                            particle.vx += dx * force * 0.01;
                            particle.vy += dy * force * 0.01;
                        }
                        
                        particle.x += particle.vx;
                        particle.y += particle.vy;
                        particle.vx *= 0.95;
                        particle.vy *= 0.95;
                        
                        // Keep within bounds
                        if (particle.x < 0) particle.x = window.innerWidth;
                        if (particle.x > window.innerWidth) particle.x = 0;
                        if (particle.y < 0) particle.y = window.innerHeight;
                        if (particle.y > window.innerHeight) particle.y = 0;
                        
                        particle.element.style.left = particle.x + 'px';
                        particle.element.style.top = particle.y + 'px';
                        
                        // Update opacity based on distance
                        const opacity = Math.max(0.3, 1 - distance / 300);
                        particle.element.style.opacity = opacity;
                    });
                });
                
                console.log('CSS fallback particle effect initialized');
            }
            
            function animate() {
                requestAnimationFrame(animate);
                
                const time = Date.now() * 0.001;
                
                if (particles.length > 0) {
                    // Smooth mouse following
                    mouseX += (targetMouseX - mouseX) * 0.05;
                    mouseY += (targetMouseY - mouseY) * 0.05;
                    
                    // Convert mouse coordinates to world space
                    const mouseWorldX = (mouseX / window.innerWidth) * 20 - 10;
                    const mouseWorldY = -(mouseY / window.innerHeight) * 15 + 7.5;
                    
                    // Boid algorithm implementation
                    particles.forEach((particle, index) => {
                        const userData = particle.userData;
                        
                        // Age the particle
                        userData.age += 0.5;
                        
                        // Boid forces
                        let separationForceX = 0, separationForceY = 0;
                        let alignmentForceX = 0, alignmentForceY = 0;
                        let cohesionForceX = 0, cohesionForceY = 0;
                        let separationCount = 0, alignmentCount = 0, cohesionCount = 0;
                        
                        // Check neighbors for boid behavior
                        particles.forEach((other, otherIndex) => {
                            if (index === otherIndex) return;
                            
                            const dx = other.position.x - particle.position.x;
                            const dy = other.position.y - particle.position.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            // Separation - avoid crowding neighbors
                            if (distance < userData.separationRadius && distance > 0) {
                                separationForceX -= dx / distance;
                                separationForceY -= dy / distance;
                                separationCount++;
                            }
                            
                            // Alignment - steer towards average heading of neighbors
                            if (distance < userData.alignmentRadius && distance > 0) {
                                alignmentForceX += other.userData.velocityX;
                                alignmentForceY += other.userData.velocityY;
                                alignmentCount++;
                            }
                            
                            // Cohesion - steer towards average position of neighbors
                            if (distance < userData.cohesionRadius && distance > 0) {
                                cohesionForceX += dx;
                                cohesionForceY += dy;
                                cohesionCount++;
                            }
                        });
                        
                        // Average the forces
                        if (separationCount > 0) {
                            separationForceX /= separationCount;
                            separationForceY /= separationCount;
                        }
                        
                        if (alignmentCount > 0) {
                            alignmentForceX /= alignmentCount;
                            alignmentForceY /= alignmentCount;
                        }
                        
                        if (cohesionCount > 0) {
                            cohesionForceX /= cohesionCount;
                            cohesionForceY /= cohesionCount;
                        }
                        
                        // Mouse attraction when hovering - made faster and more responsive
                        const mouseDistance = Math.sqrt((mouseWorldX - particle.position.x) ** 2 + (mouseWorldY - particle.position.y) ** 2);
                        let mouseForceX = 0, mouseForceY = 0;
                        
                        if (mouseDistance < 5 && mouseDistance > 0.1) {
                            const mouseAttraction = 0.08 / (1 + mouseDistance * 0.2);
                            mouseForceX = (mouseWorldX - particle.position.x) * mouseAttraction;
                            mouseForceY = (mouseWorldY - particle.position.y) * mouseAttraction;
                        }
                        
                        // Random wandering behavior
                        const wanderForceX = Math.sin(time * 0.5 + userData.age * 0.1) * 0.001;
                        const wanderForceY = Math.cos(time * 0.3 + userData.age * 0.08) * 0.001;
                        
                        // Combine all forces with different weights - increased mouse force weight
                        const totalForceX = separationForceX * 1.5 + alignmentForceX * 1.0 + cohesionForceX * 0.5 + mouseForceX * 4.0 + wanderForceX;
                        const totalForceY = separationForceY * 1.5 + alignmentForceY * 1.0 + cohesionForceY * 0.5 + mouseForceY * 4.0 + wanderForceY;
                        
                        // Apply forces to velocity
                        userData.velocityX += totalForceX * userData.maxForce;
                        userData.velocityY += totalForceY * userData.maxForce;
                        
                        // Limit speed
                        const speed = Math.sqrt(userData.velocityX ** 2 + userData.velocityY ** 2);
                        if (speed > userData.maxSpeed) {
                            userData.velocityX = (userData.velocityX / speed) * userData.maxSpeed;
                            userData.velocityY = (userData.velocityY / speed) * userData.maxSpeed;
                        }
                        
                        // Apply velocity
                        particle.position.x += userData.velocityX;
                        particle.position.y += userData.velocityY;
                        
                        // Update opacity based on mouse proximity
                        const opacity = userData.baseOpacity * (0.4 + 0.6 / (1 + mouseDistance * 0.3));
                        particle.material.opacity = Math.min(opacity, 0.8);
                        
                        // Subtle rotation
                        particle.rotation.z = time * 0.1 + userData.age * 0.01;
                        
                        // Wrap around screen edges
                        if (particle.position.x > 12) particle.position.x = -12;
                        if (particle.position.x < -12) particle.position.x = 12;
                        if (particle.position.y > 9) particle.position.y = -9;
                        if (particle.position.y < -9) particle.position.y = 9;
                    });
                }
                
                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
            }
            
            // Mouse tracking
            document.addEventListener('mousemove', function(e) {
                targetMouseX = e.clientX;
                targetMouseY = e.clientY;
            });
            
            // Handle window resize
            window.addEventListener('resize', function() {
                if (camera && renderer) {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            });
            
            // Initialize Three.js when page loads
            if (typeof THREE !== 'undefined') {
                initThreeJS();
            } else {
                console.error('Three.js library not loaded');
            }
        });
    </script>
    
    <!-- Clippy Assistant Scripts -->
    <!-- Modern Clippy Assistant Scripts - Loaded after main content -->
    <script type="module">
        let clippy;
        let randomMovementInterval;
        
        function startRandomAnimations() {
            if (randomMovementInterval) clearInterval(randomMovementInterval);
            
            randomMovementInterval = setInterval(() => {
                if (!clippy) return;
                
                // Use correct animation names from modern-clippy
                const animations = ['Idle', 'Wave', 'Thinking', 'Explain', 'GetAttention', 'Congratulate'];
                const randomAnimation = animations[Math.floor(Math.random() * animations.length)];
                
                clippy.play(randomAnimation);
                
                // Occasionally speak random messages
                if (Math.random() < 0.4) {
                    const messages = [
                        "Need any help?",
                        "I'm here if you need assistance!",
                        "Exploring the website?",
                        "Let me know if you have questions!",
                        "Looking good!",
                        "How's it going?",
                        "Anything I can help with?"
                    ];
                    const randomMessage = messages[Math.floor(Math.random() * messages.length)];
                    setTimeout(() => {
                        clippy.speak(randomMessage);
                    }, 500);
                }
            }, 3000 + Math.random() * 4000); // Faster interval between 3-7 seconds
        }
        
        async function initModernClippy() {
            try {
                // Dynamic import to load Clippy after main content
                const { initClippy } = await import('/static/modern-clippy.js');
                
                clippy = await initClippy({ basePath: '/static/' });
                
                // Add drag functionality
                let isDragging = false;
                let dragOffset = { x: 0, y: 0 };
                
                const clippyContainer = clippy.container;
                
                // Mouse down event
                clippyContainer.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    const rect = clippyContainer.getBoundingClientRect();
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                    clippyContainer.style.cursor = 'grabbing';
                    
                    // Stop animations while dragging
                    if (randomMovementInterval) {
                        clearInterval(randomMovementInterval);
                        randomMovementInterval = null;
                    }
                    
                    e.preventDefault();
                });
                
                // Mouse move event
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const newX = window.innerWidth - (e.clientX - dragOffset.x + clippyContainer.offsetWidth);
                    const newY = window.innerHeight - (e.clientY - dragOffset.y + clippyContainer.offsetHeight);
                    
                    // Keep within bounds
                    const boundedX = Math.max(20, Math.min(newX, window.innerWidth - 150));
                    const boundedY = Math.max(20, Math.min(newY, window.innerHeight - 120));
                    
                    clippyContainer.style.right = boundedX + 'px';
                    clippyContainer.style.bottom = boundedY + 'px';
                });
                
                // Mouse up event
                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        clippyContainer.style.cursor = 'grab';
                        
                        // Restart animations after a brief delay
                        setTimeout(() => {
                            if (!randomMovementInterval) {
                                startRandomAnimations();
                            }
                        }, 2000);
                    }
                });
                
                // Set initial cursor
                clippyContainer.style.cursor = 'grab';
                
                // Welcome message
                setTimeout(() => {
                    clippy.play('GetAttention');
                    setTimeout(() => {
                        clippy.speak("Hello! I'm your assistant. I'm here to help you navigate this website!");
                        // Start random animations after welcome
                        setTimeout(startRandomAnimations, 2000);
                    }, 500);
                }, 1000);
                
            } catch (error) {
                console.error('Failed to initialize Modern Clippy:', error);
            }
        }
        
        // Initialize after main content is fully loaded
        window.addEventListener('load', () => {
            // Add delay to ensure main content is prioritized
            setTimeout(initModernClippy, 1000);
        });
    </script>
    
</body>
</html>